From 55cbddc471b6caf27355ce93d1534d894e6ed0bb Mon Sep 17 00:00:00 2001
From: Leif Lindholm <leif.lindholm@linaro.org>
Date: Wed, 4 Dec 2013 15:21:16 +0000
Subject: [PATCH 2/2] arm64: add EFI Linux loader

Signed-off-by: Leif Lindholm <leif.lindholm@linaro.org>
---
 grub-core/Makefile.core.def       |   4 +-
 grub-core/loader/arm64/linux.c    | 252 ++++++++++++++++++++++++++++++++++
 grub-core/loader/arm64/linuxefi.c | 279 ++++++++++++++++++++++++++++++++++++++
 include/grub/arm64/linux.h        |  54 ++++++++
 include/grub/efi/api.h            |   4 +
 5 files changed, 592 insertions(+), 1 deletion(-)
 create mode 100644 grub-core/loader/arm64/linux.c
 create mode 100644 grub-core/loader/arm64/linuxefi.c
 create mode 100644 include/grub/arm64/linux.h

diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 060de44..7cf91a6 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -1663,7 +1663,9 @@ module = {
   sparc64_ieee1275 = loader/sparc64/ieee1275/linux.c;
   ia64_efi = loader/ia64/efi/linux.c;
   arm = loader/arm/linux.c;
-  arm = lib/fdt.c;
+  arm64 = loader/arm64/linux.c;
+  arm64 = loader/arm64/linuxefi.c;
+  fdt = lib/fdt.c;
   common = loader/linux.c;
   common = lib/cmdline.c;
   enable = noemu;
diff --git a/grub-core/loader/arm64/linux.c b/grub-core/loader/arm64/linux.c
new file mode 100644
index 0000000..38821c9
--- /dev/null
+++ b/grub-core/loader/arm64/linux.c
@@ -0,0 +1,252 @@
+/* Helper functions for the generic UEFI Linux loader */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/command.h>
+#include <grub/err.h>
+#include <grub/file.h>
+#include <grub/fdt.h>
+#include <grub/mm.h>
+#include <grub/cpu/linux.h>
+#include <grub/efi/efi.h>
+
+static grub_efi_guid_t fdt_guid = GRUB_EFI_DEVICE_TREE_GUID;
+
+static int chosen;
+
+static grub_addr_t initrd_start;
+static grub_addr_t initrd_end;
+
+static void * fw_fdt;
+static void * fdt;
+
+static char *linux_args;
+
+static void
+get_fdt (void)
+{
+  grub_efi_configuration_table_t * tables;
+  unsigned int i;
+  int size;
+
+  /* If already loaded, just return address. */
+  if (fdt)
+    return;
+
+  tables = grub_efi_system_table->configuration_table;
+
+  if (!fw_fdt)
+    /* Look for FDT in UEFI config tables. */
+    for (i=0; i < grub_efi_system_table->num_table_entries; i++)
+      if (grub_memcmp (&tables[i].vendor_guid, &fdt_guid, sizeof (fdt_guid))
+	  == 0)
+	{
+	  fw_fdt = tables[i].vendor_table;
+	  grub_dprintf("linux", "found registered FDT @ 0x%p\n", fw_fdt);
+	  break;
+	}
+
+  size = fw_fdt ? grub_fdt_get_totalsize (fw_fdt) : 0;
+  size += grub_strlen (linux_args) + 0x400;
+
+  grub_dprintf("linux", "allocating %d bytes for fdt\n", size);
+  fdt = grub_malloc (size);
+  if (!fdt)
+    return;
+
+  if (fw_fdt)
+    {
+      grub_memmove (fdt, fw_fdt, size);
+      grub_fdt_set_totalsize (fdt, size);
+    }
+  else
+    {
+      grub_fdt_create_empty_tree (fdt, size);
+    }
+}
+
+static int
+get_chosen (void)
+{
+  chosen = grub_fdt_find_subnode (fdt, 0, "chosen");
+  grub_printf("chosen: 0x%08x\n", chosen);
+  if (chosen < 0)
+    {
+      grub_dprintf ("linux", "No 'chosen' node in FDT - creating.\n");
+      chosen = grub_fdt_add_subnode (fdt, 0, "chosen");
+      if (chosen < 0)
+	return 0;
+      grub_printf("chosen=0x%08x\n", chosen);
+    }
+
+  return chosen;
+}
+
+
+grub_err_t
+grub_linux_init_params (void)
+{
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_linux_check_kernel (struct linux_kernel_header *lh)
+{
+  if (lh->magic != GRUB_LINUX_MAGIC)
+    return GRUB_ERR_BAD_OS;
+
+  if ((lh->code0 & 0xffff) == 0x5A4D)
+    grub_dprintf ("linux", "UEFI stub kernel\n");
+  else
+    grub_dprintf ("linux", "Plain Image kernel\n");
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_linux_register_cmdline (void * addr)
+{
+  linux_args = addr;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_linux_register_initrd (void * addr, grub_size_t size)
+{
+  initrd_start = (grub_addr_t) addr;
+  initrd_end = initrd_start + size;
+
+  return GRUB_ERR_NONE;
+}
+
+grub_err_t
+grub_linux_finalize_params (void)
+{
+  grub_efi_boot_services_t *b;
+  grub_efi_status_t status;
+  int node, retval;
+
+  get_fdt();
+  if (!fdt)
+    goto failure;
+
+  node = get_chosen();
+  if (node < 1)
+    goto failure;
+
+  /* Generate and set command line */
+  retval = grub_fdt_set_prop (fdt, node, "bootargs", linux_args,
+			     grub_strlen (linux_args) + 1);
+  if (retval)
+    {
+      grub_dprintf("linux", "failed to set command line\n");
+      goto failure;
+    }
+
+  grub_dprintf ("linux", "linux command line: '%s'\n", linux_args);
+
+  b = grub_efi_system_table->boot_services;
+  status = b->install_configuration_table (&fdt_guid, fdt);
+  if (status != GRUB_EFI_SUCCESS)
+    return GRUB_ERR_BAD_OS;
+
+  grub_dprintf ("linux", "Installed/updated FDT configuration table!\n");
+  grub_dprintf ("linux", " @ %p\n", fdt);
+
+  return GRUB_ERR_NONE;
+
+ failure:
+  return GRUB_ERR_BAD_OS;
+}
+
+static void *
+load_dtb (const char * filename)
+{
+  grub_file_t dtb;
+  void * tmp_fdt;
+  int size;
+
+  tmp_fdt = NULL;
+  dtb = grub_file_open (filename);
+  if (!dtb)
+    {
+      grub_error (GRUB_ERR_FILE_NOT_FOUND, N_("failed to open file"));
+      return NULL;
+    }
+
+  size = grub_file_size (dtb);
+  if (size == 0)
+      goto out;
+
+  tmp_fdt = grub_malloc (size);
+  if (!tmp_fdt)
+    goto out;
+
+  if (grub_file_read (dtb, tmp_fdt, size) != size)
+    {
+      grub_free (tmp_fdt);
+      return NULL;
+    }
+
+  if (grub_fdt_check_header (tmp_fdt, size) != 0)
+    {
+      grub_free (tmp_fdt);
+      return NULL;
+    }
+
+ out:
+  grub_file_close (dtb);
+  return tmp_fdt;
+}
+
+static grub_err_t
+grub_cmd_devicetree (grub_command_t cmd __attribute__ ((unused)),
+		     int argc, char *argv[])
+{
+  void *blob;
+
+  if (argc != 1)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+
+  grub_free(fdt);
+
+  blob = load_dtb (argv[0]);
+  if (!blob)
+    return GRUB_ERR_FILE_NOT_FOUND;
+
+  fw_fdt = blob;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_command_t cmd_devicetree;
+
+void
+grub_efi_linux_arch_register_commands (void)
+{
+  cmd_devicetree =
+    grub_register_command ("devicetree", grub_cmd_devicetree, 0,
+			   N_("Load DTB file."));
+}
+
+void
+grub_efi_linux_arch_unregister_commands (void)
+{
+  grub_unregister_command (cmd_devicetree);
+}
diff --git a/grub-core/loader/arm64/linuxefi.c b/grub-core/loader/arm64/linuxefi.c
new file mode 100644
index 0000000..71d11f4
--- /dev/null
+++ b/grub-core/loader/arm64/linuxefi.c
@@ -0,0 +1,279 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/loader.h>
+#include <grub/file.h>
+#include <grub/err.h>
+#include <grub/types.h>
+#include <grub/mm.h>
+#include <grub/cpu/linux.h>
+#include <grub/command.h>
+#include <grub/i18n.h>
+#include <grub/lib/cmdline.h>
+#include <grub/efi/efi.h>
+#include <grub/efi/pe32.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_dl_t my_mod;
+static int loaded;
+static void *kernel_mem;
+static grub_uint64_t kernel_size;
+static void *initrd_mem;
+static grub_uint32_t initrd_size;
+static char *linux_cmdline;
+
+static grub_uint32_t cmdline_size;
+
+#define GRUB_EFI_PAGE_SHIFT	12
+#define BYTES_TO_PAGES(bytes)   (((bytes) + 0xfff) >> GRUB_EFI_PAGE_SHIFT)
+
+typedef void (* handover_func) (grub_efi_handle_t, grub_efi_system_table_t *, void *);
+
+static grub_err_t
+grub_linuxefi_boot (void)
+{
+  handover_func hf;
+  struct linux_kernel_header *lh = kernel_mem;
+  struct grub_pe32_optional_header *oh;
+  grub_err_t retval;
+
+  retval = grub_linux_finalize_params();
+  if (retval != GRUB_ERR_NONE)
+    return retval;
+
+  grub_printf ("PE/COFF header @ %08x\n", lh->hdr_offset);
+  oh = (void *) ((grub_addr_t) kernel_mem + sizeof ("PE\0") + lh->hdr_offset
+		 + sizeof (struct grub_pe32_coff_header));
+
+  grub_printf ("Entry point: 0x%08x\n", oh->entry_addr);
+  hf = (handover_func) ((char *) kernel_mem + oh->entry_addr);
+  grub_printf ("hf: %p\n", (void *) hf);
+  grub_printf("grub_efi_image_handle: %p\n", grub_efi_image_handle);
+  grub_printf("grub_efi_system_table: %p\n", grub_efi_system_table);
+
+  hf (grub_efi_image_handle, grub_efi_system_table, grub_linux_get_params());
+
+  grub_printf("holy shit!\n");
+
+  /* Not reached */
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_linuxefi_unload (void)
+{
+  grub_dl_unref (my_mod);
+  loaded = 0;
+  if (initrd_mem)
+    grub_efi_free_pages((grub_efi_physical_address_t)initrd_mem,
+			BYTES_TO_PAGES(initrd_size));
+  if (kernel_mem)
+    grub_efi_free_pages((grub_efi_physical_address_t)kernel_mem,
+			BYTES_TO_PAGES(kernel_size));
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_cmd_initrdefi (grub_command_t cmd __attribute__ ((unused)),
+		    int argc, char *argv[])
+{
+  grub_file_t *files = 0;
+  int i, nfiles = 0;
+  grub_size_t size = 0;
+  grub_uint8_t *ptr;
+
+  if (argc == 0)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+      goto fail;
+    }
+
+  if (!loaded)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT,
+		  N_("you need to load the kernel first"));
+      goto fail;
+    }
+
+  files = grub_zalloc (argc * sizeof (files[0]));
+  if (!files)
+    goto fail;
+
+  for (i = 0; i < argc; i++)
+    {
+      grub_file_filter_disable_compression ();
+      files[i] = grub_file_open (argv[i]);
+      if (! files[i])
+        goto fail;
+      nfiles++;
+      size += ALIGN_UP (grub_file_size (files[i]), 4);
+    }
+
+  initrd_mem = grub_efi_allocate_pages (0, BYTES_TO_PAGES(size));
+
+  if (!initrd_mem)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("can't allocate initrd"));
+      goto fail;
+    }
+
+  grub_linux_register_initrd (initrd_mem, size);
+
+  ptr = initrd_mem;
+
+  for (i = 0; i < nfiles; i++)
+    {
+      grub_ssize_t cursize = grub_file_size (files[i]);
+      if (grub_file_read (files[i], ptr, cursize) != cursize)
+        {
+          if (!grub_errno)
+            grub_error (GRUB_ERR_FILE_READ_ERROR,
+			N_("premature end of file %s"), argv[i]);
+          goto fail;
+        }
+      ptr += cursize;
+      grub_memset (ptr, 0, ALIGN_UP_OVERHEAD (cursize, 4));
+      ptr += ALIGN_UP_OVERHEAD (cursize, 4);
+    }
+
+ fail:
+  for (i = 0; i < nfiles; i++)
+    grub_file_close (files[i]);
+  grub_free (files);
+
+  if (initrd_mem && grub_errno)
+    grub_efi_free_pages((grub_efi_physical_address_t) initrd_mem,
+			BYTES_TO_PAGES(size));
+
+  return grub_errno;
+}
+
+static grub_err_t
+grub_cmd_linuxefi (grub_command_t cmd __attribute__ ((unused)),
+		   int argc, char *argv[])
+{
+  grub_file_t file = 0;
+  struct linux_kernel_header *lh;
+  grub_ssize_t filelen;
+
+  grub_dl_ref (my_mod);
+
+  if (argc == 0)
+    {
+      grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+      goto fail;
+    }
+
+  file = grub_file_open (argv[0]);
+  if (! file)
+    goto fail;
+
+  filelen = grub_file_size (file);
+
+  grub_printf ("kernel file size: %lld\n", (long long) filelen);
+  kernel_mem = grub_efi_allocate_pages (0, BYTES_TO_PAGES(filelen));
+  grub_printf ("kernel numpages: %lld\n", (long long) BYTES_TO_PAGES(filelen));
+  if (!kernel_mem)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("can't allocate kernel"));
+      goto fail;
+    }
+
+  if (grub_file_read (file, kernel_mem, filelen) != filelen)
+    {
+      grub_error (GRUB_ERR_FILE_READ_ERROR, N_("Can't read kernel %s"),
+		  argv[0]);
+      goto fail;
+    }
+
+  lh = (void *) kernel_mem;
+  grub_dprintf ("linux", "kernel_mem @ %p\n", kernel_mem);
+  grub_dprintf ("linux", "code0: 0x%08x\n", lh->code0);
+  grub_dprintf ("linux", "code1: 0x%08x\n", lh->code1);
+  grub_dprintf ("linux", "text_offset: 0x%016llx\n",
+		(long long unsigned) lh->text_offset);
+  grub_dprintf ("linux", "magic: 0x%08x\n", lh->magic);
+  grub_dprintf ("linux", "hdr_offset: 0x%08llx\n",
+		(long long unsigned) lh->hdr_offset);
+
+  if (grub_linux_init_params() != GRUB_ERR_NONE)
+    {
+      grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate kernel parameters");
+      goto fail;
+    }
+
+  cmdline_size = grub_loader_cmdline_size (argc, argv);
+
+  linux_cmdline = grub_malloc(cmdline_size + sizeof (LINUX_IMAGE));
+  if (!linux_cmdline)
+    grub_error (GRUB_ERR_OUT_OF_MEMORY, "cannot allocate command line");
+  grub_memcpy (linux_cmdline, LINUX_IMAGE, sizeof (LINUX_IMAGE));
+  grub_create_loader_cmdline (argc, argv,
+                              linux_cmdline + sizeof (LINUX_IMAGE) - 1,
+			      cmdline_size);
+
+  grub_linux_register_cmdline (linux_cmdline);
+
+  if (grub_errno == GRUB_ERR_NONE)
+    {
+      grub_loader_set (grub_linuxefi_boot, grub_linuxefi_unload, 0);
+      loaded = 1;
+    }
+
+ fail:
+
+  if (file)
+    grub_file_close (file);
+
+  if (grub_errno != GRUB_ERR_NONE)
+    {
+      grub_dl_unref (my_mod);
+      loaded = 0;
+    }
+
+  if (linux_cmdline && !loaded)
+    grub_efi_free_pages ((grub_efi_physical_address_t) linux_cmdline,
+			 BYTES_TO_PAGES(cmdline_size));
+
+  if (kernel_mem && !loaded)
+    grub_efi_free_pages ((grub_efi_physical_address_t) kernel_mem,
+			 BYTES_TO_PAGES(kernel_size));
+
+  return grub_errno;
+}
+
+static grub_command_t cmd_linuxefi, cmd_initrdefi;
+
+GRUB_MOD_INIT(linuxefi)
+{
+  cmd_linuxefi =
+    grub_register_command ("linuxefi", grub_cmd_linuxefi, 0, N_("Load Linux."));
+  cmd_initrdefi =
+    grub_register_command ("initrdefi", grub_cmd_initrdefi,
+			   0, N_("Load initrd."));
+  grub_efi_linux_arch_register_commands();
+  my_mod = mod;
+}
+
+GRUB_MOD_FINI(linuxefi)
+{
+  grub_unregister_command (cmd_linuxefi);
+  grub_unregister_command (cmd_initrdefi);
+  grub_efi_linux_arch_unregister_commands();
+}
diff --git a/include/grub/arm64/linux.h b/include/grub/arm64/linux.h
new file mode 100644
index 0000000..9529bc3
--- /dev/null
+++ b/include/grub/arm64/linux.h
@@ -0,0 +1,54 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2013  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_LINUX_CPU_HEADER
+#define GRUB_LINUX_CPU_HEADER 1
+
+#include <grub/efi/efi.h>
+
+#define GRUB_EFI_KERNEL_STUB_ENTRY_OFFSET 0
+#define GRUB_LINUX_MAX_LOAD_ADDR 0xffffffffffffULL
+
+#define GRUB_LINUX_MAGIC 0x644d5241 /* 'ARM\x64' */
+
+/* From linux/Documentation/arm64/booting.txt */
+struct linux_kernel_header
+{
+  grub_uint32_t code0;		/* Executable code */
+  grub_uint32_t code1;		/* Executable code */
+  grub_uint64_t text_offset;    /* Image load offset */
+  grub_uint64_t res0;		/* reserved */
+  grub_uint64_t res1;		/* reserved */
+  grub_uint64_t res2;		/* reserved */
+  grub_uint64_t res3;		/* reserved */
+  grub_uint64_t res4;		/* reserved */
+  grub_uint32_t magic;		/* Magic number, little endian, "ARM\x64" */
+  grub_uint32_t hdr_offset;	/* Offset of PE/COFF header */
+};
+
+#define grub_linux_get_params() NULL
+extern grub_err_t grub_linux_init_params (void);
+extern grub_err_t grub_linux_finalize_params (void);
+extern grub_err_t grub_linux_check_kernel (struct linux_kernel_header *lh);
+extern grub_err_t grub_linux_register_cmdline (void * addr);
+extern grub_err_t grub_linux_register_initrd (void * addr, grub_size_t size);
+
+extern void grub_efi_linux_arch_register_commands (void);
+extern void grub_efi_linux_arch_unregister_commands (void);
+
+#endif /* ! GRUB_LINUX_CPU_HEADER */
diff --git a/include/grub/efi/api.h b/include/grub/efi/api.h
index 3af0911..055b01d 100644
--- a/include/grub/efi/api.h
+++ b/include/grub/efi/api.h
@@ -276,6 +276,10 @@
       { 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 } \
   }
 
+#define GRUB_EFI_DEVICE_TREE_GUID \
+  { 0xb1b621d5, 0xf19c, 0x41a5, \
+      { 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0 } \
+  }
 struct grub_efi_sal_system_table
 {
   grub_uint32_t signature;
-- 
1.8.4.2

